Welcome back to Let's go On Chris Ba guard and today, we going to be talking about vertex shade in the Betty game engine. Now the scene you before you is just two objects. There is a cube on top. There's a three d cube, not just a two d even though it looks like that because of the way placed on the camera. And then there's also the plane underneath it, which you can tell from the wire is actually just a flat plane that we've applied a vertex shade or two that moves the ver based on some simple noise in this case to make these mountains and valleys, which are really interesting to look at and yeah, I just wanna to talk a little bit about how to create this effect, and I'm going to take this effect further in future videos. So let's get it. So first off, we've only got two files. We've got main dot, which includes our bev code and we've got land vertex cheater dot w g l. Now land vertex shade dot w gs s l is our vertex shade, which is mostly the same as the default vertex for everybody. So a lot of these functions like mesh position local to world are just coming from the default vertex that betty uses for everything. And then this additional code here is what we've added to change the color and the position of the Ver c's on this plane. Now before we dive into that code, let's talk through the bev code. So aside from all of the items we bring in scope at the top, We've got a source ambient white light. I've got a pink color on the background. I've set some W settings. So I enabled the Poly mode line feature, which is required for that wire frame effect on the plane that we saw earlier, the default bev plug, the wireframe plugin, which we also need for the wire stuff. The shade plug in is the library of shade scripts that provide the noise that we've been using in every video up until this point. And then this land material is the plane that we see on the bottom of the... I don't I'm calling it a landscape. And then we set up we animate a light around the cube. That's why you see it kind of blinking in the beginning of the video. This movement controls the camera and the cube. So we move both of them forward through space to get that nice animated kind of like moving through the landscape effect. And change position is passing the position of where we are, specifically, I believe cube into the vertex shade so that we can do an offset and things like that. I've got the ship component just to label the cube as, you know, the ship quote unquote. There is no ship at the moment. I need to figure out how to import a G f file to use that. But it seems to be broken on the main branch right now. So I'm just not doing it correctly. Our setup function sets up all of our objects in the scene. First, we've got a three d bundle that is set right behind the cube. And we've put on it. Movable is a component that our leader system will query to so that we can use the arrow keys to move our cube through space and as well as our camera. We have a directional light that kind of circles the cube. So we have a system that animate the light around the queue. And then this is our interesting part. So in our previous videos, we've got taken a mesh from something like Cube from plain. Or something that is built into bev. In this case, I have defined my own structure here to make a one thousand unit piece of land in this case, it's just kind of like a really big plane. And then num ver is the number of subdivision between the edges that I want. So a higher number here will get us smoother curves and a lower number here will get us more jagged edges. Now because we're using a vertex shade, one of the things that I wanna do is input a bunch of basically taking the positions for each vertex and inputting them as a color so that each of these ver has a color corresponding to the position that it existed. I find that this creates a nice effect when I'm just getting started with a project and sometimes when I'm debugging I'll go back and forth between this kind of like rainbow e and the actual effect, which in this case is like a pink world. And this having this rainbow spread across all of the ver is one way for me to know for sure that when I change the colors, it's changing to either the shade that I wrote or the defaults. So all was is doing is getting the position attributes for all the ver. We get them as a v three So it's a three item back of float thirty fuse or f thirty two's, and that comes back to us as positions as a v we map over those, we use each of these values as a color value, and then we collect it back into back and set it as the color. Instead of the position attribute. And when I disable the vertex shade later, you'll see these colors come through. So this is where we're defining them. We also have to spawn the land in as the mesh. So we add the mesh. We give it a position in this case, it's like slightly below cube, and then we instant our land material, which is the struck that will control which shade are used to apply to this mesh. In this case I passed in time because I always like to use time, but in this case, we're not using it yet. And we are also passing in the ship position. So that's the x y the coordinate of the transform for the cube in world space. Then, of course, we've got our cube. It's a standard material, so we could, you know, text it if we wanted to or whatnot. This is gonna get replaced with a G f. In the future. So... Yeah. Now much just say is a cube. It's kinda small. It's less spending unit at its place in front of the camera. We also have movable on ship is what I'm calling it. As well as the camera. So if we move forward, we move forward and tandem, the enemy like the direction we've gone over in the past, basically moving the light the directional light around the cube. That's what causes it to look like it's flashing a little bit. Or slowly as the light rotates around. Like you change position is the land material. So we get a land material assets. We hit iterate over them. For all the land material assets, we pass in the current position of the ship. We get the transform for any entity that has the ship component in this case that's the cube. So wherever that ship is in World space, we take that x y z equal coordinate and we pass it into the ship position. On our material as a v. This is the really interesting part We've got the material implementation for land material. This just points to the vertex shade. You can see that I have some scaffolding code in here for the alpha value or the fragment, whatever in case I wanna do that future. And then we've got the lan material here. The land material has an arbitrary Eu id just needs to be unique basically, we derived as buying group and the other things we need, and we define time and ship position as uniforms. So time is an f thirty two and ship position is a x three, uniforms again, are read only data that are sent to all of the sort of processing units. Right? So when we're programming for the Gpu, any pixel can be processed anywhere on the Gpu basically because they all get processed extremely in parallel. And uniforms are basically the data that gets copied to send to wherever the processing is happening. So in this case, we get a read only timestamp stamp in a read only position for each of the shade or for each of the shade that is being processed. So in contrast to the land material, we do have this lens truck. The lan struck defines the size and a number of ver that we went over before, and then we implement from land for mesh. From and into our really interesting traits and rest. But, basically, if we have a land, we can turn it into a mesh by using this from function on the land. In this case, all I'm doing is taking the plain size and dividing it by two and treating that as either the positive or negative maximum for the plane. So if you in a plane as like a square on a x y, like or, the negative most x value and the negative most y value are gonna be in the bottom left square of that x y coordinate. Whereas the positives are gonna be in the top right, if x is positive and y is negative is gonna be the bottom right and so on. So if say you've got a one unit plane, bottom left coordinate is gonna be negative one negative one for x and y. It'll be one one in the top right, for x and for y, and then some combination of the two, four the other two x and y position. So it is in the top left, it's negative x and positive y, if in the bottom right, it's a positive x and a negative way. So that's what is here. Because we're trying to place this plane and basically in the middle of that x y grid. Jump takes the number of ver that we've defined. So if we have say a plane of size ten, and we want ten boxes to be sub divided out of that, so basically five on each side of the middle line, this is the increment to go from zero to one from one to two, two to three, across the accent across the y at the same time. Now to create a mesh, we actually have to create all of the triangles ourselves. So for the ver, we get to just do zero to numb ver. So whatever number we passed in. And then we teaching product that was zero to number ver. So if this is like, zero to ten and zero to ten, then what we get back is a Y x combination of the all of the points on grid, basically. So we'll get zero one zero two zero three zero four etcetera. We map over all of those points. And we we create two triangles out of each of them, basically. We map over all of those points and we say, okay, Each of the increments that we need we need one of them. We do need to move the increment to the left by half of the width of the plane that we're working with. So when we're thinking about x times the increment number. We're using that as it's kind of an absolute number from zero to ten, but we needed it to be from negative five to five to fit in the middle of the x y who or nick. So we do x times the increment and then we subtract half of the width of the plane. This second array value or the second value is the normal. So in this case, all of our triangles are pointing up So we've got the x value the y value in the z value. So this is basically the vector if we drew vector straight out of the plane itself. Which direction would it be facing? It would be facing straight up in the y coordinate space. And then we set our points is basically x and y, out of the number of ver. So instead of making the plain bigger, if we have more ver, we're sub dividing the plane, So we need to be at... Let's say, if we are a plane of size ten, we need to have zero one two three four five six seven eight nine. And we collect that into back and use it for any of the rest of the calculations that we need. Now the other complicated piece of this is that now that we have all of of ver for our planes. So if we've got, like, a ten by ten plane, we've got a hundred ver. Right? We need to create the indexes for all of the triangles that make up that plane. So if we have a hundred squares or ten squares or something like that. Then we are going to need to split up all of those squares into triangles. So every square can be made of two triangles, and that's what we're doing here. We're basically if we have one square and say we've got points zero one two and three. We can draw triangle by going zero one two and then a triangle from zero two three. For example, that's what this is doing. We're getting all of the points again using carte product. We en over them to get which index they are at. In the list because we do need one single list here. And then we do a filter map if we are at sort of the edges. So the very right most edge or the very top most edge then we can't draw a triangle from there to anywhere. Because we're going kind of from the bottom left to the top right. So if we are, for example, all the way on the right side of x, there is no, like, x plus one for us to be at So these are basically taking the index and pointing to each of these points. So if we have a row of ten ver, for example, and then we have... And we're at a, like, point zero. We can draw two triangles in this case we would draw zero So if we look at these more of a visual representation, we can see that if we say start at this point, we can draw a triangle by going across and back and that gives us this point that point that point, which defines this triangle and then we can also go from say this point that point and that point and which defines the other triangle, and then we get two triangles for this all square here. The math is a little f. It depends on kind of what order you have your ver in and it also... If we scroll down a little bit, we use flatten twice by the way. Because we return some and then an array of two points or two triangles. We wanna flatten all of that into a single list because we're using triangle list here, which is a single list of three points next to each other. So we would have one v of zero one two zero two three, and that would be two triangles, but it would be one v, which is a little bit confusing, but that's just the way we have to pack the data. So we get all the positions for all the ver. We get all the normal for all of the ver and we get all of the Uv for all of the ver, which is what we've defined above. Actually, do we get to Uv? Oh, I I don't think I explained you these correctly. Uv are say we have a plane. Zero zeros in the bottom left, one one is in the top right, and then that's our Uv coordinate space. So that's what this x and y r it's Uv coordinates. It's not necessarily point coordinates on the x y plane that we are thinking of. It is its own space. Right? When I say world space or Uv space, this is defining a space that starts at zero zero ends at one one and represents the entire plane that we are working with. So for all x, we have to be, like, if x is zero, then we're at zero over number ver. Hit x five, then we are at five over the number of ver. So if we have ten ver, we're halfway through. That kind of thing. And then we set the indexes on the mesh. We set the attribute... We set the position of the ver on the mesh. And we set the normal for all of the ver disease. It's confusing here because everything is kind of set in a different place and the ordering matters and all of that kind of stuff, but maybe i'll do another video on a more produced video of what it takes to actually create this mesh because it is a little confusing. And it took me a few tries to create the triangles correctly. So that seems like something worth doing. And then we've got movable and anything with the movable component on it gets picked up by this movement system. And we move either plus and we move either plus or minus in the z direction or plus or minus in the x direction using the arrow keys. As we've done before. So if we go back and, we look at our demo here, we can go left and right and forward and back, and all of that still work. Now as I move forward here, you can see a little bit of a up and down bump that's attributable to the sign calculation that we're about to see in the f jet. So to start with we're gonna take the vertex position and we're gonna create a noise value out of it. This is the value that is going to give us either the high mountain or the low valley for our y coordinate. Remember this noise value is going to be from negative one to one. And then we set the color of the vertex to rg b alpha using a v four. Again, we don't have, like, complicated types here. We just have a v four and we can pass kind of any information that we want to out of this in the past, we've actually passed the position here to access that in the fragment. But in this case, it's half red whatever noise value we have and then half blue. And this this is from negative one to one. Right? So if you look at the color values that are below one. They're kind of all, like very saturated out and washed out and, like, they all look kind of the same. That's what gives us this little bit of, like, fog ish effect down there. I can take the the mesh off later too and show that a little bit more So then the world position of the vertex. So the position of the vertex as it stands in the actual entire game scene. Is created by passing in the model which has our mesh information on it. And then the vertex position for x, the vertex position for z, and the noise value for why? And this noise value for why is how we get the peaks in the values in our vertex position. I've done some additional stuff here. So to get the noise to behave a little bit differently as the ship moves through. I've taken the ship position. And you can see that I've calculated the offset from where the ship is to where in the world we are. And I've applied assign wave to that with an amplitude of four. So if you multiply for by sin wave, you get a bigger amplitude, right? Because sign goes from negative one to one. So in this case, we'll go from negative four to four. We divide that by a hundred. Seems like a good number. It's arbitrary. This is a magic number here. And then we set the new world position to the old world position minus that value. So I'm trying to get this kind of up and down effect. And I might switch to this to be something a little bit more like world c So instead of seeing the vertex go up and down here as they're traveling past our cube, we could have this signed be the total representation out to the end and be kind of like a world horizon instead of this flat horizon that we have sticking out from our plane. And then we do the same for clip position. I'm gonna be honest. I don't quite understand the difference between clip position and world position. I think clip position has something to do with when the stuff on the screen stops rendering, but that is something that I left in from the default vertex and Actually, we can do this. If we don't include the clip position, we actually don't get any output. So critically important to have the clip position as well as the world position But I'm gonna be honest. I don't understand clip position yet. There will be a future video on what clip position is because I need to go look it up. And that's it. I mean, we've got a cube we've got a plane. We've got the planes sub divided into triangles. We've got the ability to move on third plane. So we can go forward and back or left to right we're both are a bunch of them. And this is a one thousand by one thousand planes, so we're kind of in the middle of it right now. And there are a thousand ver. So it's kind of jagged. We can cancel that. And I wanna show two things here before we leave. Let's take a look at... I don't know if this will work if I'm being honest. Okay. My entire computer is slowing down. Okay. Well, that was a fun experiment. My entire computer is slowing down. Instead of making it ten thousand. Let's make the size of the land mass down to a hundred and we can see how a thousand ver creates this nice, like, very smooth result. Compared to what we had before. And you can see the ver on the ground here, that they are much smaller than before So if you're looking for something a little bit more blob, this is a better approach you're looking for something that's a little bit more fragment, I think that fewer ver works better. Let's do one more thing. Let's move this back to being a thousand build the server, and then let's remove the wire. So here we've got a wireframe. The wireframe is on the land mass. If we remove the wireframe from betty, we won't see the outline of the plane as it exists in the system anymore. Then we will just get to see kind of our our land masses going by. So you can see that the color below zero kind of clips out and creates this fog effect, We don't see the wire anymore. We could put the wireframe on the cube as well. But but, yeah, I'm hoping to put a spaceship inside of this and Yeah. We'll see. I don't know. I don't know where I'm gonna go with this one. But I hope that you learned a little bit about vertex shade. They're really cool. It's it's really fun to kind of mess with the position in the rendering that the vertex are supposed to be. You could easily see this used for water or something like that. And hopefully, you can see how, like we can get a flat plane to look kind of mountainous and completely different without actually changing anything in the mesh. So I will catch you next time, and I hope you enjoyed this episode of Let's cook. As always, the code will be linked in the description. And if you have any questions, leave a comment Have you liked the video. Triple a like. It helps out. I'll catch you next time.